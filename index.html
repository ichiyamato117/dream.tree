<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Dream Tree Forest</title>
    <style>
        body { margin: 0; background: #fdfcf0; font-family: sans-serif; overflow: hidden; touch-action: none; }
        #viewport { width: 100vw; height: 100vh; cursor: grab; overflow: hidden; background: linear-gradient(#e0f7fa, #fdfcf0); }
        #world { position: absolute; top: 0; left: 0; transform-origin: 0 0; }
        svg { position: absolute; top: 0; left: 0; width: 5000px; height: 5000px; pointer-events: none; z-index: 1; }
        
        .branch-path { fill: none; stroke: #5d4037; stroke-linecap: round; transition: stroke-width 0.5s ease; }

        .node {
            position: absolute; width: 130px; height: 65px;
            cursor: pointer; z-index: 10; font-weight: bold; font-size: 14px;
            display: flex; align-items: center; justify-content: center;
            user-select: none; transform: translate(-50%, -50%);
            border-radius: 50% 10% 50% 10% / 50% 10% 50% 10%;
            transition: background 0.3s, transform 0.1s; color: white; padding: 10px; box-sizing: border-box; text-align: center;
            box-shadow: 2px 4px 8px rgba(0,0,0,0.15);
            animation: sway 4s ease-in-out infinite;
        }

        @keyframes sway {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            50% { transform: translate(-50%, -52%) rotate(2deg); }
        }
        
        .node.root-node {
            width: 220px; height: 110px; background: #3e2723 !important; 
            border-radius: 50% 50% 20% 20% / 100% 100% 10% 10% !important;
            font-size: 24px; border-bottom: 12px solid #261613;
            animation: none; z-index: 5;
        }

        .status-0 { background: #66bb6a; } .status-1 { background: #ffa726; } .status-2 { background: #ef5350; }

        .menu-bar { position: fixed; top: 20px; left: 20px; z-index: 100; display: flex; flex-direction: column; gap: 10px; }
        .controls { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 100; }
        button { padding: 12px 20px; border: none; border-radius: 25px; background: #2e7d32; color: white; cursor: pointer; font-weight: bold; }
        .guide-box { position: fixed; top: 20px; right: 20px; background: rgba(255,255,255,0.8); padding: 10px 15px; border-radius: 12px; font-size: 12px; color: #333; box-shadow: 0 2px 10px rgba(0,0,0,0.1); pointer-events: none; z-index: 100; }
    </style>
</head>
<body>

    <div id="viewport">
        <div id="world">
            <svg id="svg-layer"></svg>
            <div id="nodes-layer"></div>
        </div>
    </div>

    <div class="guide-box">
        <b>ã€æ“ä½œã‚¬ã‚¤ãƒ‰ã€‘</b><br>
        1å›ï¼šæè¿½åŠ  / 2å›ï¼šç´…è‘‰<br>
        3å›ï¼šå‰Šé™¤ / ãƒ‰ãƒ©ãƒƒã‚°ï¼šç§»å‹•
    </div>

    <div class="menu-bar">
        <select id="tree-selector" onchange="switchTree()" style="padding:10px; border-radius:10px;"></select>
        <button onclick="resetView()" style="background:#ffa000;">ğŸ” æœ¨ã‚’è¦‹ã¤ã‘ã‚‹</button>
        <button onclick="addNewTree()">ğŸ†• 2æœ¬ç›®ã‚’æ¤ãˆã‚‹</button>
        <button onclick="captureImage()" style="background:#0277bd;">ğŸ“¸ ãƒ‡ãƒ¼ã‚¿ä¿å­˜</button>
    </div>

    <div class="controls">
        <button id="seed-btn" onclick="showModal(null)">ğŸŒ± ç¨®ã‚’æ¤ãˆã‚‹</button>
    </div>

    <div id="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:1000; justify-content:center; align-items:center;">
        <div style="background:white; padding:30px; border-radius:25px; width:85%; max-width:380px; text-align:center;">
            <textarea id="node-input" rows="4" style="width:100%; padding:15px; border:2px solid #eee; border-radius:15px; font-size:16px; margin-bottom:15px;"></textarea>
            <button onclick="confirmInput()" style="width:100%; padding:15px; background:#2e7d32; color:white; border:none; border-radius:12px;">æ±ºå®š</button>
            <button onclick="closeModal()" style="background:none; border:none; color:#999; margin-top:10px;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        </div>
    </div>

    <script>
        let forest = JSON.parse(localStorage.getItem('dreamForest')) || { "My Dream": [] };
        let currentTreeName = Object.keys(forest)[0];
        let selectedParentId = null, scale = 1, viewX = 0, viewY = 0, isPanning = false, panStartX, panStartY, draggedNode = null;
        let lastPinchDist = 0; // ãƒ”ãƒ³ãƒæ“ä½œç”¨

        function init() { updateSelector(); setupInteractions(); resetView(); render(); }

        function resetView() {
            scale = 0.5; // å°‘ã—å¼•ãæ°—å‘³ã§é–‹å§‹
            const tree = forest[currentTreeName];
            if (tree.length > 0) {
                viewX = window.innerWidth / 2 - tree[0].x * scale;
                viewY = window.innerHeight / 2 - (tree[0].y - 200) * scale;
            } else {
                viewX = window.innerWidth / 2 - 2500 * scale; 
                viewY = window.innerHeight / 2 - 2500 * scale;
            }
            applyTransform();
        }

        function setupInteractions() {
            const vp = document.getElementById('viewport');
            
            vp.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    lastPinchDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                } else if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    if (touch.target.classList.contains('node')) {
                        draggedNode = forest[currentTreeName].find(n => n.id == touch.target.dataset.id);
                    } else {
                        isPanning = true;
                        panStartX = touch.clientX - viewX;
                        panStartY = touch.clientY - viewY;
                    }
                }
            }, { passive: false });

            vp.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 2) {
                    const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                    const zoom = dist / lastPinchDist;
                    scale = Math.min(Math.max(0.05, scale * zoom), 3); // ä¸‹é™ã‚’ 0.05 ã«æ‹¡å¤§
                    lastPinchDist = dist;
                    applyTransform();
                } else if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    if (draggedNode) {
                        draggedNode.x = (touch.clientX - viewX) / scale;
                        draggedNode.y = (touch.clientY - viewY) / scale;
                        render();
                    } else if (isPanning) {
                        viewX = touch.clientX - panStartX;
                        viewY = touch.clientY - panStartY;
                        applyTransform();
                    }
                }
            }, { passive: false });

            vp.addEventListener('touchend', () => {
                if (draggedNode) save();
                draggedNode = null;
                isPanning = false;
            });

            // ãƒã‚¦ã‚¹æ“ä½œï¼ˆPCç”¨ï¼‰
            vp.onpointerdown = (e) => {
                if (e.pointerType === 'touch') return;
                if (e.target.classList.contains('node')) draggedNode = forest[currentTreeName].find(n => n.id == e.target.dataset.id);
                else { isPanning = true; panStartX = e.clientX - viewX; panStartY = e.clientY - viewY; }
            };
            window.onpointermove = (e) => {
                if (e.pointerType === 'touch') return;
                if (draggedNode) { draggedNode.x = (e.clientX - viewX) / scale; draggedNode.y = (e.clientY - viewY) / scale; render(); }
                else if (isPanning) { viewX = e.clientX - panStartX; viewY = e.clientY - panStartY; applyTransform(); }
            };
            window.onpointerup = () => { if (draggedNode) save(); draggedNode = null; isPanning = false; };
            vp.onwheel = (e) => { e.preventDefault(); scale *= (e.deltaY > 0 ? 0.95 : 1.05); scale = Math.min(Math.max(0.05, scale), 3); applyTransform(); };
        }

        function applyTransform() { document.getElementById('world').style.transform = `translate(${viewX}px, ${viewY}px) scale(${scale})`; }

        function render() {
            const svg = document.getElementById('svg-layer');
            const nodesLayer = document.getElementById('nodes-layer');
            const tree = forest[currentTreeName];
            svg.innerHTML = ''; nodesLayer.innerHTML = '';
            document.getElementById('seed-btn').style.display = tree.length === 0 ? 'block' : 'none';

            const totalNodes = tree.length;
            const growthFactor = Math.floor(totalNodes / 2);

            tree.forEach((node, index) => {
                if (node.parentId) {
                    const parent = tree.find(n => n.id === node.parentId);
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("class", "branch-path");
                    const dy = parent.y - node.y;
                    const d = `M ${parent.x} ${parent.y} C ${parent.x} ${parent.y - dy * 0.85} ${node.x} ${parent.y - dy * 0.15} ${node.x} ${node.y}`;
                    path.setAttribute("d", d);
                    const depth = getDepth(node);
                    const baseWidth = Math.max(4, 25 - depth * 5);
                    path.setAttribute("stroke-width", baseWidth + growthFactor); 
                    svg.appendChild(path);
                }
                const div = document.createElement('div');
                div.className = `node status-${node.status} ${node.isRoot ? 'root-node' : ''}`;
                div.style.left = node.x + 'px'; div.style.top = node.y + 'px';
                div.dataset.id = node.id;
                div.innerText = node.text;
                div.style.animationDelay = `${index * -0.5}s`;
                
                let clickCount = 0;
                let clickTimer = null;

                div.addEventListener('click', (e) => {
                    clickCount++;
                    if (clickCount === 1) {
                        clickTimer = setTimeout(() => {
                            if (clickCount === 1) showModal(node.id); // 1å›ï¼šæè¿½åŠ 
                            else if (clickCount === 2) cycleStatus(node.id); // 2å›ï¼šç´…è‘‰
                            else if (clickCount === 3) deleteNode(node.id); // 3å›ï¼šå‰Šé™¤
                            clickCount = 0;
                        }, 400); // åˆ¤å®šæ™‚é–“ã‚’å°‘ã—é•·ã‚ã«(400ms)
                    }
                });
                
                nodesLayer.appendChild(div);
            });
        }

        function cycleStatus(id) {
            const node = forest[currentTreeName].find(n => n.id == id);
            node.status = (node.status + 1) % 3;
            if(node.status === 2) setChildrenStatus(id, 2);
            save(); render();
        }
        function setChildrenStatus(pid, s) { forest[currentTreeName].filter(n => n.parentId == pid).forEach(c => { c.status = s; setChildrenStatus(c.id, s); }); }
        function deleteNode(id) { if(!confirm("æã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) return; const tree = forest[currentTreeName]; const toD = [id]; const findC = (p) => { tree.filter(n => n.parentId == p).forEach(c => { toD.push(c.id); findC(c.id); }); }; findC(id); forest[currentTreeName] = tree.filter(n => !toD.includes(n.id)); save(); render(); }
        function save() { localStorage.setItem('dreamForest', JSON.stringify(forest)); }
        function updateSelector() { const sel = document.getElementById('tree-selector'); sel.innerHTML = ''; Object.keys(forest).forEach(name => { const opt = document.createElement('option'); opt.value = name; opt.innerText = name; if(name === currentTreeName) opt.selected = true; sel.appendChild(opt); }); }
        function addNewTree() { const name = prompt("æœ¨ã®åå‰"); if (name && !forest[name]) { forest[name] = []; currentTreeName = name; save(); updateSelector(); render(); resetView(); } }
        function switchTree() { currentTreeName = document.getElementById('tree-selector').value; render(); resetView(); }
        function showModal(parentId) { selectedParentId = parentId; document.getElementById('modal').style.display = 'flex'; }
        function closeModal() { document.getElementById('modal').style.display = 'none'; document.getElementById('node-input').value = ''; }
        function confirmInput() { const text = document.getElementById('node-input').value; if (!text.trim()) return; const items = text.split('\n').filter(i => i.trim() !== ""); if (forest[currentTreeName].length === 0) { createNode(items[0], 2500, 2500, null, true); resetView(); } else { const pId = selectedParentId || forest[currentTreeName][0].id; items.forEach((item, index) => addBranch(pId, item, index, items.length)); } save(); closeModal(); render(); }
        function createNode(text, x, y, parentId = null, isRoot = false) { forest[currentTreeName].push({ id: Date.now() + Math.random(), text, x, y, parentId, status: 0, isRoot }); }
        function addBranch(pId, text, index, total) { const parent = forest[currentTreeName].find(n => n.id === pId); const angle = ((-90 - 35) + (70 / (total === 1 ? 1 : total - 1)) * index) * (Math.PI / 180); const dist = 320; createNode(text, parent.x + Math.cos(angle)*dist, parent.y + Math.sin(angle)*dist, pId); }
        function getDepth(node) { let d = 0, curr = node; while(curr && curr.parentId) { d++; curr = forest[currentTreeName].find(n => n.id === curr.parentId); } return d; }
        function captureImage() { const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(forest)); const downloadAnchorNode = document.createElement('a'); downloadAnchorNode.setAttribute("href", dataStr); downloadAnchorNode.setAttribute("download", "dream_tree_data.json"); document.body.appendChild(downloadAnchorNode); downloadAnchorNode.click(); downloadAnchorNode.remove(); alert("ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚");
